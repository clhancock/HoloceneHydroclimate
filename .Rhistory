#setup and run ensemble ########## This is the main part of the code to edit ##########
registerDoParallel(2)
ensOut <- foreach::foreach(i = 1:nens) %dopar% {
tc <- compositeR::compositeEnsembles	(lipdRegion,
binvec,
stanFun = compositeR::standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = compositeR::simpleBinTs) #sampleEnsembleThenBinTs
return(list(composite = tc$composite,count = tc$count))
}
#
# Return reconstruction and additional data for plotting
compositeEnsVals[[region]]  <- as.matrix(purrr::map_dfc(ensOut,extract,"composite"))
medianCompositeTS[[region]] <- apply(compositeEnsVals[[region]],1,median)
}
map_dbl <- purrr::map_dbl
ensOut <- foreach(i = 1:nens) %dopar% {
tc <- compositeR::compositeEnsembles	(lipdRegion,
binvec,
stanFun = compositeR::standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = compositeR::simpleBinTs) #sampleEnsembleThenBinTs
return(list(composite = tc$composite,count = tc$count))
}
compositeR::compositeEnsembles	(lipdRegion,
binvec,
stanFun = compositeR::standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = compositeR::simpleBinTs) #sampleEnsembleThenBinTs
return(list(composite = tc$composite,count = tc$count))
}
tc <- compositeR::compositeEnsembles	(lipdRegion,
binvec,
stanFun = compositeR::standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = compositeR::simpleBinTs) #sampleEnsembleThenBinTs
View(tc)
tc
tc$composite
tc$composite
compEns <- list()
for (i in 1:nens){
tc <- compositeR::compositeEnsembles	(lipdRegion,
binvec,
stanFun = compositeR::standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = compositeR::simpleBinTs) #sampleEnsembleThenBinTs
compEns[i] <- tc$composite
}
compEns
View(compEns)
tc$composite
for (i in 1:nens){print(i)
}
i
tc <- compositeR::compositeEnsembles	(lipdRegion,
binvec,
stanFun = compositeR::standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = compositeR::simpleBinTs) #sampleEnsembleThenBinTs
tc
$composite
compEns <- list()
for (i in 1:nens){
tc <- compositeR::compositeEnsembles	(lipdRegion,
binvec,
stanFun = compositeR::standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = compositeR::simpleBinTs) #sampleEnsembleThenBinTs
compEns[i] <- tc$composite
}
tc[i]
tc[1]
tc[2]
tc[3]
compEns[1]
compEns[[1]]
tc$composite]
tc$composite
compEns <- vector(mode=list)
for (i in 1:nens){
tc <- compositeR::compositeEnsembles	(lipdRegion,
binvec,
stanFun = compositeR::standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = compositeR::simpleBinTs) #sampleEnsembleThenBinTs
compEns[i] <- tc$composite
}
compEns[i]
tc$composite
compEns[i] <- tc$composite
binvec
length(binvec)
length(binYears)
compEns <- matrix(NA,nrow = length(binYears),ncol=nens)
for (i in 1:nens){
tc <- compositeR::compositeEnsembles	(lipdRegion,
binvec,
stanFun = compositeR::standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = compositeR::simpleBinTs) #sampleEnsembleThenBinTs
compEns[,i] <- tc$composite
}
compEns
View(compEns)
#set.seed(#) Set same sets of records which will make completely reproducable
#
#Set variables for composite code
nens          <- 10  #make low to run quickly, set high to get large ensemble range (variation from standardization search range and order )
binsize       <- 200 #years
ageMin        <- 0 #age BP
ageMax        <- 12000 #age BP
searchAgeMin  <- 0 #age BP
searchAgeMax  <- 8000 #age BP
searchDuration<-(ageMax-ageMin)/4 #yrs
minNrecords   <- 6 #num of records
#
binvec   <- seq(ageMin-binsize/2, to = ageMax+binsize/2, by = binsize)
binYears <- rowMeans(cbind(binvec[-1],binvec[-length(binvec)]))
#Set up data to add once
compositeEns      <- vector(mode="list")
medianCompositeTS <- data_frame(time=binYears)
for (region in regionNames) {
#Filter the TS by cluster name and make sure have enough values
lipdRegion <- filterTs(lipdTSO,paste('geo_ipccRegion ==',region))
#Skip if number of records is too few
if(length(lipdRegion)<minNrecords|sum(pullTsVariable(lipdRegion,'archiveType')!="LakeDeposits")<5|region=='SAS')next
#
#setup and run ensemble ########## This is the main part of the code to edit ##########
compEns <- matrix(NA,nrow = length(binYears),ncol=nens)
for (i in 1:nens){
tc <- compositeR::compositeEnsembles	(lipdRegion,
binvec,
stanFun = compositeR::standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = compositeR::simpleBinTs) #sampleEnsembleThenBinTs
compEns[,i] <- tc$composite
}
#
# Return reconstruction and additional data for plotting
compositeEns[[region]]  <- compEns
medianCompositeTS[[region]] <- apply(compositeEns[[region]],1,median)
}
tc <- compositeR::compositeEnsembles	(lipdRegion,
binvec,
stanFun = standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = simpleBinTs) #sampleEnsembleThenBinTs
#set.seed(#) Set same sets of records which will make completely reproducable
#
#Set variables for composite code
nens          <- 10  #make low to run quickly, set high to get large ensemble range (variation from standardization search range and order )
binsize       <- 200 #years
ageMin        <- 0 #age BP
ageMax        <- 12000 #age BP
searchAgeMin  <- 0 #age BP
searchAgeMax  <- 8000 #age BP
searchDuration<-(ageMax-ageMin)/4 #yrs
minNrecords   <- 6 #num of records
#
binvec   <- seq(ageMin-binsize/2, to = ageMax+binsize/2, by = binsize)
binYears <- rowMeans(cbind(binvec[-1],binvec[-length(binvec)]))
#Set up data to add once
compositeEns      <- vector(mode="list")
medianCompositeTS <- data_frame(time=binYears)
for (region in regionNames) {
#Filter the TS by cluster name and make sure have enough values
lipdRegion <- filterTs(lipdTSO,paste('geo_ipccRegion ==',region))
#Skip if number of records is too few
if(length(lipdRegion)<minNrecords|sum(pullTsVariable(lipdRegion,'archiveType')!="LakeDeposits")<5|region=='SAS')next
#
#setup and run ensemble ########## This is the main part of the code to edit ##########
compEns <- matrix(NA,nrow = length(binYears),ncol=nens)
for (i in 1:nens){
tc <- compositeR::compositeEnsembles	(lipdRegion,
binvec,
stanFun = standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = simpleBinTs) #sampleEnsembleThenBinTs
compEns[,i] <- tc$composite
}
#
# Return reconstruction and additional data for plotting
compositeEns[[region]]  <- compEns
medianCompositeTS[[region]] <- apply(compositeEns[[region]],1,median)
}
region <- 'EAS'
lipdRegion <- filterTs(lipdTSO,paste('geo_ipccRegion ==',region))
#Skip if number of records is too few
if(length(lipdRegion)<minNrecords|sum(pullTsVariable(lipdRegion,'archiveType')!="LakeDeposits")<5|region=='SAS')next
#
#setup and run ensemble ########## This is the main part of the code to edit ##########
compEns <- matrix(NA,nrow = length(binYears),ncol=nens)
for (i in 1:nens){
tc <- compositeR::compositeEnsembles	(lipdRegion,
binvec,
stanFun = standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = simpleBinTs) #sampleEnsembleThenBinTs
compEns[,i] <- tc$composite
}
#
plot(binYears,compEns[,i] )
view(standardizeMeanIteratively)
standardizeMeanIteratively <- function (ages, pdm, duration, searchRange, normalizeVariance = TRUE,
thresh = 0.01, minN = 3)
{
start <- standardizeOverRandomInterval(ages = ages, pdm = pdm,
duration = duration, searchRange = searchRange, normalizeVariance = normalizeVariance,
minN = minN)
start[!is.finite(start)] <- NA
colsds <- apply(pdm, 2, sd, na.rm = TRUE)
filledBins <- apply(pdm, 2, function(x) sum(is.finite(x)))
bad <- which(colSums(is.finite(start)) == 0 | colsds < 0.1 |
filledBins < minN)
if (length(bad) >= (NCOL(start) - 2)) {
stop("No good columns after standardization")
}
delta <- thresh + 1
meanAllRMSE <- 1000
upmat <- start
while (delta > thresh) {
allRMSE <- matrix(NA, nrow = ncol(start))
rvec <- sample(1:ncol(start))
for (j in rvec) {
es <- recordRMSE(upmat[, j], upmat)
meanBias <- es$totalBias
upmat[, j] <- upmat[, j] - meanBias
allRMSE[j] <- es$totalRMSE
}
old <- meanAllRMSE
meanAllRMSE <- mean(allRMSE, na.rm = TRUE)
delta <- old - meanAllRMSE
}
return(upmat)
}
compEns <- matrix(NA,nrow = length(binYears),ncol=nens)
for (i in 1:nens){
tc <- compositeR::compositeEnsembles	(lipdRegion,
binvec,
stanFun = standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = simpleBinTs) #sampleEnsembleThenBinTs
compEns[,i] <- tc$composite
}
plot(binYears,compEns[,i] )
compositeEnsembles	(lipdRegion,
binvec,
stanFun = standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = simpleBinTs) #sampleEnsembleThenBinTs
compEns <- matrix(NA,nrow = length(binYears),ncol=nens)
for (i in 1:nens){
tc <- compositeEnsembles(lipdRegion,
binvec,
stanFun = standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = simpleBinTs) #sampleEnsembleThenBinTs
compEns[,i] <- tc$composite
}
compositeEnsembles(lipdRegion,
binvec,
stanFun = standardizeMeanIteratively(minN=4),
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = simpleBinTs) #sampleEnsembleThenBinTs
compositeEnsembles(lipdRegion,
binvec,
stanFun = standardizeMeanIteratively(ageVar = "age",minN=4),
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = simpleBinTs) #sampleEnsembleThenBinTs
#set.seed(#) Set same sets of records which will make completely reproducable
#
#Set variables for composite code
nens          <- 100  #make low to run quickly, set high to get large ensemble range (variation from standardization search range and order )
binsize       <- 200 #years
ageMin        <- 0 #age BP
ageMax        <- 12000 #age BP
searchAgeMin  <- 0 #age BP
searchAgeMax  <- 8000 #age BP
searchDuration<-(ageMax-ageMin)/4 #yrs
minNrecords   <- 6 #num of records
#
binvec   <- seq(ageMin-binsize/2, to = ageMax+binsize/2, by = binsize)
binYears <- rowMeans(cbind(binvec[-1],binvec[-length(binvec)]))
#Set up data to add once
compositeEns      <- vector(mode="list")
medianCompositeTS <- data_frame(time=binYears)
for (region in regionNames) {
#Filter the TS by cluster name and make sure have enough values
lipdRegion <- filterTs(lipdTSO,paste('geo_ipccRegion ==',region))
#Skip if number of records is too few
if(length(lipdRegion)<minNrecords|sum(pullTsVariable(lipdRegion,'archiveType')!="LakeDeposits")<5|region=='SAS')next
#
#setup and run ensemble ########## This is the main part of the code to edit ##########
compEns <- matrix(NA,nrow = length(binYears),ncol=nens)
for (i in 1:nens){
tc <- compositeEnsembles(lipdRegion,
binvec,
stanFun = standardizeMeanIteratively,
ageVar  = "age",
alignInterpDirection = TRUE,
spread      = TRUE,
duration    = searchDuration,
searchRange = c(searchAgeMin,searchAgeMax),
normalizeVariance = TRUE,
scope = "climate",
binFun = simpleBinTs) #sampleEnsembleThenBinTs
compEns[,i] <- tc$composite
}
#
# Return reconstruction and additional data for plotting
compositeEns[[region]]  <- compEns
medianCompositeTS[[region]] <- apply(compositeEns[[region]],1,median)
}
library(compositeR)
library(geoChronR)
library(ncdf4)
library(tidyverse)
modelDict <- vector(mode="list")
#
modelDict$trace <- vector(mode="list")
modelDict$trace$name   <- c('/trace.01-36.22000BP.cam2.','.22000BP_decavg','_400BCE.nc')
modelDict$trace$precip <- c(name='PRECT',slope=(60*60*24*1000),intercept=0) #converts m/s to mm/day
modelDict$trace$evap   <- c(name='QFLX',slope=(1/1000)*(60*60*24*1000),intercept=0) #converts kg/m2/s to m/s to mm/day
#modelDict$trace$temp   <- c(name='TEMP',slope=1,intercept=-273.15)  #converts K to degC
modelDict$trace$time   <- c(name='time',slope=-1000,intercept=0) #To 0-12ka Holocene
modelDict$trace$lat    <- c(name='lat',slope=1,intercept=0)
modelDict$trace$lon    <- c(name='lon',slope=1,intercept=0)
#
modelDict$hadcm <- vector(mode="list")
modelDict$hadcm$name   <- c('/deglh.vn1_0.','.monthly.','.nc')
modelDict$hadcm$precip <- c(name='precip_mm_srf',slope=(1/1000)*(60*60*24*1000),intercept=0) #converts kg/m2/s to m/s to mm/day
modelDict$hadcm$evap   <- c(name='totalEvap_mm_srf',slope=1,intercept=0) #already in mm/day
#modelDict$hadcm$temp   <- c(name='temp_mm_1_5m',slope=1,intercept=-273.15)  #converts K to degC
modelDict$hadcm$time   <- c(name='t',slope=-1,intercept=2000) #To 0-12ka Holocene
modelDict$hadcm$lat    <- c(name='latitude',slope=1,intercept=0)
modelDict$hadcm$lon    <- c(name='longitude',slope=1,intercept=0)
#
modelData <- vector(mode="list")
for (model in names(modelDict)){
modelData[[model]] <- vector(mode="list")
dataPath <-paste(dataDir,'Model/',sep='')
for (season in c('ANN','DJF','JJA')){
print(season)
data <- vector(mode="list")
for (variable in c('precip','evap')){
variableData <- nc_open(paste(dataPath,model,
modelDict[[model]][['name']][1],
modelDict[[model]][[variable]]['name'],
modelDict[[model]][['name']][2],
season,
modelDict[[model]][['name']][3],
sep=''))
data[[variable]] <- ncvar_get(variableData, modelDict[[model]][[variable]]['name'])
}
data$lon  <- ncvar_get(variableData, modelDict[[model]]$lon['name'])
data$lon  <- ifelse(data$lon > 180, -360 + data$lon, data$lon)
data$lat  <- ncvar_get(variableData, modelDict[[model]]$lat['name'])
data$time <- ncvar_get(variableData, modelDict[[model]]$time['name'])
for (variable in names(modelDict[[model]][-1])){
data[[variable]] <- data[[variable]]*as.numeric(modelDict[[model]][[variable]][['slope']])+as.numeric(modelDict[[model]][[variable]][['intercept']])
}
data$pe <- data$precip - data$evap
HoloceneIndex <- which(data$time<=12050, arr.ind = TRUE)
data$time    <- data$time[HoloceneIndex]
for (variable in c('precip','evap','pe','temp')){
data[[variable]]  <- data[[variable]][,,HoloceneIndex]
}
modelData[[model]][[season]] <-data
}
}
modelData <- vector(mode="list")
for (model in names(modelDict)){
modelData[[model]] <- vector(mode="list")
dataPath <-paste(dataDir,'Model/',sep='')
for (season in c('ANN','DJF','JJA')){
print(season)
data <- vector(mode="list")
for (variable in c('precip','evap')){
variableData <- nc_open(paste(dataPath,model,
modelDict[[model]][['name']][1],
modelDict[[model]][[variable]]['name'],
modelDict[[model]][['name']][2],
season,
modelDict[[model]][['name']][3],
sep=''))
data[[variable]] <- ncvar_get(variableData, modelDict[[model]][[variable]]['name'])
}
data$lon  <- ncvar_get(variableData, modelDict[[model]]$lon['name'])
data$lon  <- ifelse(data$lon > 180, -360 + data$lon, data$lon)
data$lat  <- ncvar_get(variableData, modelDict[[model]]$lat['name'])
data$time <- ncvar_get(variableData, modelDict[[model]]$time['name'])
for (variable in names(modelDict[[model]][-1])){
data[[variable]] <- data[[variable]]*as.numeric(modelDict[[model]][[variable]][['slope']])+as.numeric(modelDict[[model]][[variable]][['intercept']])
}
data$pe <- data$precip - data$evap
HoloceneIndex <- which(data$time<=12050, arr.ind = TRUE)
data$time    <- data$time[HoloceneIndex]
for (variable in c('precip','evap','pe','temp')){
data[[variable]]  <- data[[variable]][,,HoloceneIndex]
}
modelData[[model]][[season]] <-data
}
}
