}
}
set.seed(5) #Reproducibility
ensOut <- foreach(i = 1:nens) %dopar% {
tc <- compositeEnsembles(fTS                  = lipdReg,
binvec               = binvec,
stanFun              = standardizeMeanIteratively,
binFun               = simpleBinTs,
ageVar               = "age",
alignInterpDirection = FALSE,
spread               = TRUE,
duration             = searchDur,
searchRange          = c(1000,9000),
normalizeVariance    = std,
minN                 = 3)
return(list(composite = tc$composite,count = tc$count))
}
regionComposite           <- as.matrix(purrr::map_dfc(ensOut,extract,"composite"))
rownames(regionComposite) <- binYears
compositeEnsemble[[reg]]  <- regionComposite
medianCompositeTS[[reg]]  <- apply(regionComposite,1,median,na.rm=TRUE)
#plot region to confirm that everything looks good
plotTimeseriesEnsRibbons(X = binYears,Y = compositeEnsemble[[reg]])+
scale_x_continuous(name = "age (yr BP)",         oob = scales::squish)+
scale_y_continuous(name = "Standardized Anomaly",oob = scales::squish)+
theme_bw()+
ggtitle(paste(reg,"Composite Ensemble"))
}
#ID regions to reconstruct based on number of records (nThresh)
regNames <- data.frame(name=pullTsVariable(lipdTSO,'geo_ipccRegion')) %>%
group_by(name) %>%
summarise(n = n()) %>%
filter(n >= nThresh)
regNames <- c(as.character(regNames$name),'EAN','SSA') #Add 2 SH regions with fewer records to gain global coverage
#Set up data to add once regional composite is calculated
compositeEnsemble <- vector(mode='list')
medianCompositeTS <- data_frame(time=binYears)
#Loop to composite (by region)
for (reg in c(regNames)) {
lipdReg  <- filterTs(lipdTSO,paste('geo_ipccRegion ==',reg))
for (i in 1:length(lipdReg)){
if (lipdReg[[i]]$climateInterpretation1_interpDirection == 'negative'){
lipdReg[[i]]$paleoData_values <- lipdReg[[i]]$paleoData_values*-1
}
}
set.seed(5) #Reproducibility
ensOut <- foreach(i = 1:nens) %dopar% {
tc <- compositeEnsembles(fTS                  = lipdReg,
binvec               = binvec,
stanFun              = standardizeMeanIteratively,
binFun               = simpleBinTs,
ageVar               = "age",
alignInterpDirection = FALSE,
spread               = TRUE,
duration             = searchDur,
searchRange          = c(1000,9000),
normalizeVariance    = std,
minN                 = 3)
return(list(composite = tc$composite,count = tc$count))
}
regionComposite           <- as.matrix(purrr::map_dfc(ensOut,extract,"composite"))
rownames(regionComposite) <- binYears
compositeEnsemble[[reg]]  <- regionComposite
medianCompositeTS[[reg]]  <- apply(regionComposite,1,median,na.rm=TRUE)
#plot region to confirm that everything looks good
plotTimeseriesEnsRibbons(X = binYears,Y = compositeEnsemble[[reg]])+
scale_x_continuous(name = "age (yr BP)",         oob = scales::squish)+
scale_y_continuous(name = "Standardized Anomaly",oob = scales::squish)+
theme_bw()+
ggtitle(paste(reg,"Composite Ensemble"))
}
View(medianCompositeTS)
lipdData <- readRDS(file.path(dir,'Data','Proxy','LiPD','lipdData.rds'))[[var]]
lipdTSO  <- lipdData[-which(pullTsVariable(lipdData,"climateInterpretation1_seasonalityGeneral") %in% c('Summer+','Winter+'))]
if(var == 'T'){
lipdTSO <- filterTs(lipdTSO,'paleoData_units == degC')
lipdTSO <- filterTs(lipdTSO,'paleoData_datum == abs')
std <- FALSE      #Use calibrated data so no need to normalize variance
} else{std <- TRUE} #Normalize variance because data recorded with different units
nens          <- 10     #Ensemble numbers (lower = faster)
binsize       <- 100     #years (median resolution = 107yrs)
ageMin        <- 0       #age BP
ageMax        <- 12400   #age BP
searchDur     <- 4000    #yrs (for 3 lake deposit data points)
nThresh       <- 7       #minimum no. of records, else skip
#Set bin vectors
binvec   <- seq(ageMin-binsize/2, to = ageMax+binsize/2, by = binsize)
binYears <- rowMeans(cbind(binvec[-1],binvec[-length(binvec)]))
#ID regions to reconstruct based on number of records (nThresh)
regNames <- data.frame(name=pullTsVariable(lipdTSO,'geo_ipccRegion')) %>%
group_by(name) %>%
summarise(n = n()) %>%
filter(n >= nThresh)
regNames <- c(as.character(regNames$name),'EAN','SSA') #Add 2 SH regions with fewer records to gain global coverage
#Set up data to add once regional composite is calculated
compositeEnsemble <- vector(mode='list')
medianCompositeTS <- data_frame(time=binYears)
regNames
#Set up data to add once regional composite is calculated
compositeEnsemble <- vector(mode='list')
medianCompositeTS <- data_frame(time=binYears)
lipdReg  <- filterTs(lipdTSO,paste('geo_ipccRegion ==',reg))
for (i in 1:length(lipdReg)){
if (lipdReg[[i]]$climateInterpretation1_interpDirection == 'negative'){
lipdReg[[i]]$paleoData_values <- lipdReg[[i]]$paleoData_values*-1
}
}
set.seed(5) #Reproducibility
ensOut <- foreach(i = 1:nens) %dopar% {
tc <- compositeEnsembles(fTS                  = lipdReg,
binvec               = binvec,
stanFun              = standardizeMeanIteratively,
binFun               = simpleBinTs,
ageVar               = "age",
alignInterpDirection = FALSE,
spread               = TRUE,
duration             = searchDur,
searchRange          = c(1000,9000),
normalizeVariance    = std,
minN                 = 3)
return(list(composite = tc$composite,count = tc$count))
}
nThresh       <- 20       #minimum no. of records, else skip
#Set bin vectors
binvec   <- seq(ageMin-binsize/2, to = ageMax+binsize/2, by = binsize)
binYears <- rowMeans(cbind(binvec[-1],binvec[-length(binvec)]))
#ID regions to reconstruct based on number of records (nThresh)
regNames <- data.frame(name=pullTsVariable(lipdTSO,'geo_ipccRegion')) %>%
group_by(name) %>%
summarise(n = n()) %>%
filter(n >= nThresh)
regNames <- c(as.character(regNames$name))#,'EAN','SSA') #Add 2 SH regions with fewer records to gain global coverage
#Set up data to add once regional composite is calculated
compositeEnsemble <- vector(mode='list')
medianCompositeTS <- data_frame(time=binYears)
#Loop to composite (by region)
for (reg in c(regNames)) {
lipdReg  <- filterTs(lipdTSO,paste('geo_ipccRegion ==',reg))
for (i in 1:length(lipdReg)){
if (lipdReg[[i]]$climateInterpretation1_interpDirection == 'negative'){
lipdReg[[i]]$paleoData_values <- lipdReg[[i]]$paleoData_values*-1
}
}
set.seed(5) #Reproducibility
ensOut <- foreach(i = 1:nens) %dopar% {
tc <- compositeEnsembles(fTS                  = lipdReg,
binvec               = binvec,
stanFun              = standardizeMeanIteratively,
binFun               = simpleBinTs,
ageVar               = "age",
alignInterpDirection = FALSE,
spread               = TRUE,
duration             = searchDur,
searchRange          = c(1000,9000),
normalizeVariance    = std,
minN                 = 3)
return(list(composite = tc$composite,count = tc$count))
}
regionComposite           <- as.matrix(purrr::map_dfc(ensOut,extract,"composite"))
rownames(regionComposite) <- binYears
compositeEnsemble[[reg]]  <- regionComposite
medianCompositeTS[[reg]]  <- apply(regionComposite,1,median,na.rm=TRUE)
#plot region to confirm that everything looks good
plotTimeseriesEnsRibbons(X = binYears,Y = compositeEnsemble[[reg]])+
scale_x_continuous(name = "age (yr BP)",         oob = scales::squish)+
scale_y_continuous(name = "Standardized Anomaly",oob = scales::squish)+
theme_bw()+
ggtitle(paste(reg,"Composite Ensemble"))
}
library(compositeR)
library(doParallel)
library(dplyr)
library(foreach)
library(geoChronR)
library(lipdR)
library(magrittr)
library(purrr)
library(tidyverse)
as.matrix(purrr::map_dfc(ensOut,extract,"composite"))
lipdReg  <- filterTs(lipdTSO,paste('geo_ipccRegion ==',reg))
for (i in 1:length(lipdReg)){
if (lipdReg[[i]]$climateInterpretation1_interpDirection == 'negative'){
lipdReg[[i]]$paleoData_values <- lipdReg[[i]]$paleoData_values*-1
}
}
set.seed(5) #Reproducibility
ensOut <- foreach(i = 1:nens) %dopar% {
tc <- compositeEnsembles(fTS                  = lipdReg,
binvec               = binvec,
stanFun              = standardizeMeanIteratively,
binFun               = simpleBinTs,
ageVar               = "age",
alignInterpDirection = FALSE,
spread               = TRUE,
duration             = searchDur,
searchRange          = c(1000,9000),
normalizeVariance    = std,
minN                 = 3)
return(list(composite = tc$composite,count = tc$count))
}
regionComposite           <- as.matrix(purrr::map_dfc(ensOut,extract,"composite"))
ensOut
regionComposite           <- as.matrix(purrr::map_dfc(ensOut,extract,"composite"))
regionComposite           <- as.matrix(purrr::map_dfc(ensOut,magrittr::extract,"composite"))
#Loop to composite (by region)
for (reg in c(regNames)) {
lipdReg  <- filterTs(lipdTSO,paste('geo_ipccRegion ==',reg))
for (i in 1:length(lipdReg)){
if (lipdReg[[i]]$climateInterpretation1_interpDirection == 'negative'){
lipdReg[[i]]$paleoData_values <- lipdReg[[i]]$paleoData_values*-1
}
}
set.seed(5) #Reproducibility
ensOut <- foreach(i = 1:nens) %dopar% {
tc <- compositeEnsembles(fTS                  = lipdReg,
binvec               = binvec,
stanFun              = standardizeMeanIteratively,
binFun               = simpleBinTs,
ageVar               = "age",
alignInterpDirection = FALSE,
spread               = TRUE,
duration             = searchDur,
searchRange          = c(1000,9000),
normalizeVariance    = std,
minN                 = 3)
return(list(composite = tc$composite,count = tc$count))
}
regionComposite           <- as.matrix(purrr::map_dfc(ensOut,magrittr::extract,"composite"))
rownames(regionComposite) <- binYears
compositeEnsemble[[reg]]  <- regionComposite
medianCompositeTS[[reg]]  <- apply(regionComposite,1,median,na.rm=TRUE)
#plot region to confirm that everything looks good
plotTimeseriesEnsRibbons(X = binYears,Y = compositeEnsemble[[reg]])+
scale_x_continuous(name = "age (yr BP)",         oob = scales::squish)+
scale_y_continuous(name = "Standardized Anomaly",oob = scales::squish)+
theme_bw()+
ggtitle(paste(reg,"Composite Ensemble"))
}
medianCompositeTS
medianCompositeTS$time
medianCompositeTS[1:10,]
medianCompositeTS[1:which(medianCompositeTS$time=12000),]
medianCompositeTS[1:which(medianCompositeTS$time==12000),]
medianCompositeTS[1:which(medianCompositeTS$time==12000),]$time
View(medianCompositeTS)
regionComposite[1:which(regionComposite$time==12000),]
dim(regionComposite)
dim(regionComposite[1:which(medianCompositeTS$time==12000),])
View(regionComposite)
View(regionComposite[1:which(binYears==12000),])
nens          <- 3     #Ensemble numbers (lower = faster)
binsize       <- 100     #years (median resolution = 107yrs)
ageMin        <- 0       #age BP
ageMax        <- 12400   #age BP
searchDur     <- 4000    #yrs (for 3 lake deposit data points)
nThresh       <- 20       #minimum no. of records, else skip
#Set bin vectors
binvec   <- seq(ageMin-binsize/2, to = ageMax+binsize/2, by = binsize)
binYears <- rowMeans(cbind(binvec[-1],binvec[-length(binvec)]))
#ID regions to reconstruct based on number of records (nThresh)
regNames <- data.frame(name=pullTsVariable(lipdTSO,'geo_ipccRegion')) %>%
group_by(name) %>%
summarise(n = n()) %>%
filter(n >= nThresh)
regNames <- c(as.character(regNames$name))#,'EAN','SSA') #Add 2 SH regions with fewer records to gain global coverage
#Set up data to add once regional composite is calculated
compositeEnsemble <- vector(mode='list')
medianCompositeTS <- data_frame(time=binYears)
#Loop to composite (by region)
for (reg in c(regNames)) {
lipdReg  <- filterTs(lipdTSO,paste('geo_ipccRegion ==',reg))
for (i in 1:length(lipdReg)){
if (lipdReg[[i]]$climateInterpretation1_interpDirection == 'negative'){
lipdReg[[i]]$paleoData_values <- lipdReg[[i]]$paleoData_values*-1
}
}
set.seed(5) #Reproducibility
ensOut <- foreach(i = 1:nens) %dopar% {
tc <- compositeEnsembles(fTS                  = lipdReg,
binvec               = binvec,
stanFun              = standardizeMeanIteratively,
binFun               = simpleBinTs,
ageVar               = "age",
alignInterpDirection = FALSE,
spread               = TRUE,
duration             = searchDur,
searchRange          = c(1000,9000),
normalizeVariance    = std,
minN                 = 3)
return(list(composite = tc$composite,count = tc$count))
}
regionComposite           <- as.matrix(purrr::map_dfc(ensOut,magrittr::extract,"composite"))
rownames(regionComposite) <- binYears
compositeEnsemble[[reg]]  <- regionComposite[1:which(binYears==12000),]
medianCompositeTS[[reg]]  <- apply(regionComposite,1,median,na.rm=TRUE)
#plot region to confirm that everything looks good
plotTimeseriesEnsRibbons(X = binYears,Y = compositeEnsemble[[reg]])+
scale_x_continuous(name = "age (yr BP)",         oob = scales::squish)+
scale_y_continuous(name = "Standardized Anomaly",oob = scales::squish)+
theme_bw()+
ggtitle(paste(reg,"Composite Ensemble"))
}
rownames(compositeEnsemble)
row.names(compositeEnsemble)
#plot region to confirm that everything looks good
plotTimeseriesEnsRibbons(X = binYears[1:which(binYears==12000),],Y = compositeEnsemble[[reg]])+
scale_x_continuous(name = "age (yr BP)",         oob = scales::squish)+
scale_y_continuous(name = "Standardized Anomaly",oob = scales::squish)+
theme_bw()+
ggtitle(paste(reg,"Composite Ensemble"))
binYears[1:which(binYears==12000)]
#plot region to confirm that everything looks good
plotTimeseriesEnsRibbons(X = binYears[1:which(binYears==12000)],Y = compositeEnsemble[[reg]])+
scale_x_continuous(name = "age (yr BP)",         oob = scales::squish)+
scale_y_continuous(name = "Standardized Anomaly",oob = scales::squish)+
theme_bw()+
ggtitle(paste(reg,"Composite Ensemble"))
#Set up data to add once regional composite is calculated
compositeEnsemble <- vector(mode='list')
medianCompositeTS <- data_frame(time=binYears)
#Loop to composite (by region)
for (reg in c(regNames)) {
lipdReg  <- filterTs(lipdTSO,paste('geo_ipccRegion ==',reg))
for (i in 1:length(lipdReg)){
if (lipdReg[[i]]$climateInterpretation1_interpDirection == 'negative'){
lipdReg[[i]]$paleoData_values <- lipdReg[[i]]$paleoData_values*-1
}
}
set.seed(5) #Reproducibility
ensOut <- foreach(i = 1:nens) %dopar% {
tc <- compositeEnsembles(fTS                  = lipdReg,
binvec               = binvec,
stanFun              = standardizeMeanIteratively,
binFun               = simpleBinTs,
ageVar               = "age",
alignInterpDirection = FALSE,
spread               = TRUE,
duration             = searchDur,
searchRange          = c(1000,9000),
normalizeVariance    = std,
minN                 = 3)
return(list(composite = tc$composite,count = tc$count))
}
regionComposite           <- as.matrix(purrr::map_dfc(ensOut,magrittr::extract,"composite"))
rownames(regionComposite) <- binYears
compositeEnsemble[[reg]]  <- regionComposite[1:which(binYears==12000),]
medianCompositeTS[[reg]]  <- apply(regionComposite,1,median,na.rm=TRUE)
#plot region to confirm that everything looks good
plotTimeseriesEnsRibbons(X = binYears[1:which(binYears==12000)],Y = compositeEnsemble[[reg]])+
scale_x_continuous(name = "age (yr BP)",         oob = scales::squish)+
scale_y_continuous(name = "Standardized Anomaly",oob = scales::squish)+
theme_bw()+
ggtitle(paste(reg,"Composite Ensemble"))
}
View(medianCompositeTS)
View(compositeEnsemble[[reg]])
medianCompositeTS <- data_frame(time=binYears[1:which(binYears==12000),])
medianCompositeTS <- data_frame(time=binYears[1:which(binYears==12000)])
#Loop to composite (by region)
for (reg in c(regNames)) {
lipdReg  <- filterTs(lipdTSO,paste('geo_ipccRegion ==',reg))
for (i in 1:length(lipdReg)){
if (lipdReg[[i]]$climateInterpretation1_interpDirection == 'negative'){
lipdReg[[i]]$paleoData_values <- lipdReg[[i]]$paleoData_values*-1
}
}
set.seed(5) #Reproducibility
ensOut <- foreach(i = 1:nens) %dopar% {
tc <- compositeEnsembles(fTS                  = lipdReg,
binvec               = binvec,
stanFun              = standardizeMeanIteratively,
binFun               = simpleBinTs,
ageVar               = "age",
alignInterpDirection = FALSE,
spread               = TRUE,
duration             = searchDur,
searchRange          = c(1000,9000),
normalizeVariance    = std,
minN                 = 3)
return(list(composite = tc$composite,count = tc$count))
}
regionComposite           <- as.matrix(purrr::map_dfc(ensOut,magrittr::extract,"composite"))
rownames(regionComposite) <- binYears
compositeEnsemble[[reg]]  <- regionComposite[1:which(binYears==12000),]
medianCompositeTS[[reg]]  <- apply(regionComposite,1,median,na.rm=TRUE)
#plot region to confirm that everything looks good
plotTimeseriesEnsRibbons(X = binYears[1:which(binYears==12000),],Y = compositeEnsemble[[reg]])+
scale_x_continuous(name = "age (yr BP)",         oob = scales::squish)+
scale_y_continuous(name = "Standardized Anomaly",oob = scales::squish)+
theme_bw()+
ggtitle(paste(reg,"Composite Ensemble"))
}
#Set up data to add once regional composite is calculated
compositeEnsemble <- vector(mode='list')
medianCompositeTS <- data_frame(time=binYears[1:which(binYears==12000)])
#Loop to composite (by region)
for (reg in c(regNames)) {
lipdReg  <- filterTs(lipdTSO,paste('geo_ipccRegion ==',reg))
for (i in 1:length(lipdReg)){
if (lipdReg[[i]]$climateInterpretation1_interpDirection == 'negative'){
lipdReg[[i]]$paleoData_values <- lipdReg[[i]]$paleoData_values*-1
}
}
set.seed(5) #Reproducibility
ensOut <- foreach(i = 1:nens) %dopar% {
tc <- compositeEnsembles(fTS                  = lipdReg,
binvec               = binvec,
stanFun              = standardizeMeanIteratively,
binFun               = simpleBinTs,
ageVar               = "age",
alignInterpDirection = FALSE,
spread               = TRUE,
duration             = searchDur,
searchRange          = c(1000,9000),
normalizeVariance    = std,
minN                 = 3)
return(list(composite = tc$composite,count = tc$count))
}
regionComposite           <- as.matrix(purrr::map_dfc(ensOut,magrittr::extract,"composite"))
rownames(regionComposite) <- binYears
regionComposite           <- regionComposite[1:which(binYears==12000),]
compositeEnsemble[[reg]]  <- regionComposite
medianCompositeTS[[reg]]  <- apply(regionComposite,1,median,na.rm=TRUE)
#plot region to confirm that everything looks good
plotTimeseriesEnsRibbons(X = binYears[1:which(binYears==12000),],Y = compositeEnsemble[[reg]])+
scale_x_continuous(name = "age (yr BP)",         oob = scales::squish)+
scale_y_continuous(name = "Standardized Anomaly",oob = scales::squish)+
theme_bw()+
ggtitle(paste(reg,"Composite Ensemble"))
}
View(regionComposite)
regionComposite           <- as.matrix(purrr::map_dfc(ensOut,magrittr::extract,"composite"))
rownames(regionComposite) <- binYears
regionComposite           <- regionComposite[1:which(binYears==12000),]
compositeEnsemble[[reg]]  <- regionComposite
medianCompositeTS[[reg]]  <- apply(regionComposite,1,median,na.rm=TRUE)
#plot region to confirm that everything looks good
plotTimeseriesEnsRibbons(X = binYears[1:which(binYears==12000),],Y = compositeEnsemble[[reg]])+
scale_x_continuous(name = "age (yr BP)",         oob = scales::squish)+
scale_y_continuous(name = "Standardized Anomaly",oob = scales::squish)+
theme_bw()+
ggtitle(paste(reg,"Composite Ensemble"))
dim( compositeEnsemble[[reg]])
length(binYears)
length(binYears[1:which(binYears==12000),])
nens          <- 3     #Ensemble numbers (lower = faster)
binsize       <- 100     #years (median resolution = 107yrs)
ageMin        <- 0       #age BP
ageMax        <- 12400   #age BP
searchDur     <- 4000    #yrs (for 3 lake deposit data points)
nThresh       <- 40       #minimum no. of records, else skip
#Set bin vectors
binvec   <- seq(ageMin-binsize/2, to = ageMax+binsize/2, by = binsize)
binYears <- rowMeans(cbind(binvec[-1],binvec[-length(binvec)]))
#ID regions to reconstruct based on number of records (nThresh)
regNames <- data.frame(name=pullTsVariable(lipdTSO,'geo_ipccRegion')) %>%
group_by(name) %>%
summarise(n = n()) %>%
filter(n >= nThresh)
regNames <- c(as.character(regNames$name))#,'EAN','SSA') #Add 2 SH regions with fewer records to gain global coverage
#Set up data to add once regional composite is calculated
compositeEnsemble <- vector(mode='list')
medianCompositeTS <- data_frame(time=binYears[1:which(binYears==12000)])
#Loop to composite (by region)
for (reg in c(regNames)) {
lipdReg  <- filterTs(lipdTSO,paste('geo_ipccRegion ==',reg))
for (i in 1:length(lipdReg)){
if (lipdReg[[i]]$climateInterpretation1_interpDirection == 'negative'){
lipdReg[[i]]$paleoData_values <- lipdReg[[i]]$paleoData_values*-1
}
}
set.seed(5) #Reproducibility
ensOut <- foreach(i = 1:nens) %dopar% {
tc <- compositeEnsembles(fTS                  = lipdReg,
binvec               = binvec,
stanFun              = standardizeMeanIteratively,
binFun               = simpleBinTs,
ageVar               = "age",
alignInterpDirection = FALSE,
spread               = TRUE,
duration             = searchDur,
searchRange          = c(1000,9000),
normalizeVariance    = std,
minN                 = 3)
return(list(composite = tc$composite,count = tc$count))
}
regionComposite           <- as.matrix(purrr::map_dfc(ensOut,magrittr::extract,"composite"))
rownames(regionComposite) <- binYears
regionComposite           <- regionComposite[1:which(binYears==12000),]
compositeEnsemble[[reg]]  <- regionComposite
medianCompositeTS[[reg]]  <- apply(regionComposite,1,median,na.rm=TRUE)
#plot region to confirm that everything looks good
plotTimeseriesEnsRibbons(X = binYears[1:which(binYears==12000)],Y = compositeEnsemble[[reg]])+
scale_x_continuous(name = "age (yr BP)",         oob = scales::squish)+
scale_y_continuous(name = "Standardized Anomaly",oob = scales::squish)+
theme_bw()+
ggtitle(paste(reg,"Composite Ensemble"))
}
View((compositeEnsemble[[reg]])
)
data.frame(name=pullTsVariable(lipdTSO,'geo_ipccRegion')) %>%
group_by(name) %>%
summarise(n = n()) %>%
filter(n >= nThresh)
nThresh       <- 3       #minimum no. of records, else skip
#ID regions to reconstruct based on number of records (nThresh)
regNames <- data.frame(name=pullTsVariable(lipdTSO,'geo_ipccRegion')) %>%
group_by(name) %>%
summarise(n = n()) %>%
filter(n >= nThresh)
regNames
View(regNames)
