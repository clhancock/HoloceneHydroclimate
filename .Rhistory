tsidListHC <- c(tsidListHC,ts$paleoData_TSid)
}
}
}
compNo <- compNo+1
}
}
lipdData <- list(Temp = TS_temp[which(pullTsVariable(TS_temp,"paleoData_TSid") %in% tsidListTemp)],
HC   = TS_hc[  which(pullTsVariable(TS_hc  ,"paleoData_TSid") %in% tsidListHC)])
print(paste("Temp:",length(lipdData$Temp)))
print(paste("HC:",length(lipdData$HC)))
lipd <- lipdData[['HC']]
pullTSvariable(lipdData[[climVar]],'archiveType')
pullTsVariable(lipdData[[climVar]],'archiveType')
pullTsVariable(lipdData[[climVar]],'originalDataUrl')
lipd[[703]]$originalDataUrl
'h' in 'hello'
if('h' in 'hello'){print('True')}
'hello'
'hello'[1:2]
'hello'[:2]
z  <- 'hello'
z[1:2]
contains("Hello",'He')
grepl("Hello",'He')
grepl("He",'Hello')
substr('hello',1,2)
lipd[[ts]]$dataSetName
lipd[[1]]$dataSetName
substr('lipd[[ts]]$dataSetName',1,2)
###Add metadata
for (climVar in names(lipdData)){
lipd <- lipdData[[climVar]]
for (ts in 1:length(lipd)){
lipd[[ts]]$age <- as.numeric(lipd[[ts]]$age)
lipd[[ts]]$paleoData_values <- as.numeric(lipd[[ts]]$paleoData_values)
#Make sure name of climate interp field is standardized
if (is.null(lipd[[ts]]$climateInterpretation1_direction) == FALSE){
lipd[[ts]]$climateInterpretation1_interpDirection <- lipd[[ts]]$climateInterpretation1_direction
}
#
#Add Ipcc regions to metdata
pointData <- data.frame(longitude=c(lipd[[ts]]$geo_longitude),latitude=c(lipd[[ts]]$geo_latitude))
pointData <- SpatialPointsDataFrame(coords=pointData,data = pointData,
proj4string = CRS(PROJorig))
pointData <-  spTransform(pointData, CRSobj = PROJ)
lipd[[ts]]$geo_ipccRegion <- as.character(over(pointData, refregions)$Acronym)
#
#Add age information
tso <- data.frame(age = as.numeric(lipd[[ts]]$age), values = as.numeric(lipd[[ts]]$paleoData_values)) %>%
filter(between(age,0,12000)) %>%
filter(!is.na(values)) %>%
arrange(age)
lipd[[ts]]$ageMin     <- min(tso$age)
lipd[[ts]]$ageMax     <- max(tso$age)
lipd[[ts]]$ageRange   <- diff(range(tso$age))
lipd[[ts]]$ageRes     <- median(diff(tso$age))
lipd[[ts]]$ageResPlus <- median(diff(tso$age[which(diff(tso$values) != 0)]))
#
#Add category information
if (climVar == 'HC'){
archive  <- lipd[[ts]]$archiveType
proxy    <- lipd[[ts]]$paleoData_proxy
unit     <- lipd[[ts]]$paleoData_units
if (is.null(proxy) | is.null(archive)){
lipd[[ts]]$Category         <- 'Other'
lipd[[ts]]$CategorySpecific <- 'Other (not calibrated)'
} else if (archive == 'Speleothem'){
lipd[[ts]]$Category           <- 'Speleothem'
if (proxy == 'd18O' | proxy ==  'd13C'){
lipd[[ts]]$CategorySpecific <- paste(archive,' (',proxy,')',sep='')
} else{
lipd[[ts]]$CategorySpecific <- 'Speleothem (other)'
}
} else if (archive == 'LakeDeposits'){
lipd[[ts]]$Category           <- 'Lake Deposits'
lipd[[ts]]$CategorySpecific   <- 'Lake Deposits'
} else if (archive == 'GlacierIce'){
lipd[[ts]]$Category           <- 'Glacier Ice'
lipd[[ts]]$CategorySpecific   <- 'Glacier Ice'
} else if (archive == 'LakeSediment' & proxy == 'd18O'){
lipd[[ts]]$Category           <- 'Lake Sediment d18O'
lipd[[ts]]$CategorySpecific   <- 'Lake Sediment (d18O)'
} else if (proxy == 'dDwax'){
lipd[[ts]]$Category           <- 'Leaf Wax dD'
lipd[[ts]]$CategorySpecific   <- 'Leaf Wax (dD)'
} else if (proxy == 'pollen'){
lipd[[ts]]$Category           <- 'Pollen'
if (is.null(unit)){
lipd[[ts]]$CategorySpecific <- 'Pollen (not calibrated)'
} else if (unit == 'mm' | unit == 'mm/a'){
lipd[[ts]]$CategorySpecific <- 'Pollen (calibrated)'
} else {
lipd[[ts]]$CategorySpecific <- 'Pollen (not calibrated)'
}
} else {
lipd[[ts]]$Category           <- 'Other'
if (is.null(unit)){
lipd[[ts]]$CategorySpecific <- 'Other (not calibrated)'
} else if (unit == 'mm' | unit == 'mm/a'){
lipd[[ts]]$CategorySpecific <- 'Other (calibrated)'
} else {
lipd[[ts]]$CategorySpecific <- 'Other (not calibrated)'
}
}
} else{lipd[[ts]]$Category <- lipd[[ts]]$paleoData_proxyGeneral}
#
if (climVar == 'HC'){
if (lipd[[ts]]$createdBy == 'http://github.com/nickmckay/oxfordLakeStatus2Lipd'){
lipd[[ts]]$Source = 'Oxford Lake Levels Database'
}
#  dataSource.append('Oxford Lake Status')
else if (lipd[[ts]]$createdBy =='sisal2lipd'){
lipd[[ts]]$Source = 'SISAL'
}
# dataSource.append('SISAL (Comas-Bru et al., 2020)')
else if (lipd[[ts]]$originalDataUrl == 'wNAm'){
lipd[[ts]]$Source = 'wNA'
}
# dataSource.append('wNA')
else if (lipd[[ts]]$originalDataUrl == 'geochange.er.usgs.gov/midden/'){
lipd[[ts]]$Source = 'wNA'
}
# dataSource.append('wNA')
else if (lipd[[ts]]$paleoData_calibration_method == 'JM18_MAT'){
lipd[[ts]]$Source = 'Marsicek et al. (2018)'
}
# dataSource.append('Marsicek')
else if (grepl('gov/paleo/study/15444',lipd[[ts]]$originalDataUrl) | '10.5194/cp-10-1605-2014' == lipd[[ts]]$pub2_doi){
lipd[[ts]]$Source = 'Arctic Holocene'
}
#dataSource.append('Arctic Holocene')
else if (substr('lipd[[ts]]$dataSetName',1,2) == 'LS'){
lipd[[ts]]$Source = 'iso2k'
}
# dataSource.append('iso2k')
else if (lipd[[ts]]$originalDataUrl == 'https://essd.copernicus.org/articles/12/2261/2020/'){
lipd[[ts]]$Source = 'iso2k'
}
# dataSource.append('iso2k')
else if (grepl('10.25921/4RY2-G808',lipd[[ts]]$originalDataUrl) | grepl('/paleo/study/27330',lipd[[ts]]$originalDataUrl)){
lipd[[ts]]$Source = 'Temp12k'
}
#dataSource.append('Temp12k')
else{
lipd[[ts]]$Source = 'Miscellanious'
}# dataSource.append('Miscellanious')
} else{lipd[[ts]]$Source <- 'Temp12k'}
#
}
#require >0 change points for lakedeposits
lipd                <- lipd[which(!is.na(pullTsVariable(lipd,"ageResPlus")))]
lipdData[[climVar]] <- lipd[which(pullTsVariable(lipd,"climateInterpretation1_seasonalityGeneral") %in% c('summer+','winter+') == FALSE)]
}
lipd[[ts]]$paleoData_calibration_method
else if (lipd[[ts]]$paleoData_calibration_method == 'JM18_MAT'){
lipd[[ts]]$Source = 'Marsicek et al. (2018)'
}
else if (lipd[[ts]]$paleoData_calibration_method == 'JM18_MAT'){
lipd[[ts]]$Source = 'Marsicek et al. (2018)'
}
if (lipd[[ts]]$paleoData_calibration_method == 'JM18_MAT'){
lipd[[ts]]$Source = 'Marsicek et al. (2018)'
}
if (!is.null(lipd[[ts]]$paleoData_calibration_method) $ lipd[[ts]]$paleoData_calibration_method) == 'JM18_MAT'){
lipd[[ts]]$Source = 'Marsicek et al. (2018)'
}
if (!is.null(lipd[[ts]]$paleoData_calibration_method) $ lipd[[ts]]$paleoData_calibration_method == 'JM18_MAT'){
lipd[[ts]]$Source = 'Marsicek et al. (2018)'
}
if (!is.null(lipd[[ts]]$paleoData_calibration_method) & lipd[[ts]]$paleoData_calibration_method == 'JM18_MAT'){
lipd[[ts]]$Source = 'Marsicek et al. (2018)'
}
###Add metadata
for (climVar in names(lipdData)){
lipd <- lipdData[[climVar]]
for (ts in 1:length(lipd)){
lipd[[ts]]$age <- as.numeric(lipd[[ts]]$age)
lipd[[ts]]$paleoData_values <- as.numeric(lipd[[ts]]$paleoData_values)
#Make sure name of climate interp field is standardized
if (is.null(lipd[[ts]]$climateInterpretation1_direction) == FALSE){
lipd[[ts]]$climateInterpretation1_interpDirection <- lipd[[ts]]$climateInterpretation1_direction
}
#
#Add Ipcc regions to metdata
pointData <- data.frame(longitude=c(lipd[[ts]]$geo_longitude),latitude=c(lipd[[ts]]$geo_latitude))
pointData <- SpatialPointsDataFrame(coords=pointData,data = pointData,
proj4string = CRS(PROJorig))
pointData <-  spTransform(pointData, CRSobj = PROJ)
lipd[[ts]]$geo_ipccRegion <- as.character(over(pointData, refregions)$Acronym)
#
#Add age information
tso <- data.frame(age = as.numeric(lipd[[ts]]$age), values = as.numeric(lipd[[ts]]$paleoData_values)) %>%
filter(between(age,0,12000)) %>%
filter(!is.na(values)) %>%
arrange(age)
lipd[[ts]]$ageMin     <- min(tso$age)
lipd[[ts]]$ageMax     <- max(tso$age)
lipd[[ts]]$ageRange   <- diff(range(tso$age))
lipd[[ts]]$ageRes     <- median(diff(tso$age))
lipd[[ts]]$ageResPlus <- median(diff(tso$age[which(diff(tso$values) != 0)]))
#
#Add category information
if (climVar == 'HC'){
archive  <- lipd[[ts]]$archiveType
proxy    <- lipd[[ts]]$paleoData_proxy
unit     <- lipd[[ts]]$paleoData_units
if (is.null(proxy) | is.null(archive)){
lipd[[ts]]$Category         <- 'Other'
lipd[[ts]]$CategorySpecific <- 'Other (not calibrated)'
} else if (archive == 'Speleothem'){
lipd[[ts]]$Category           <- 'Speleothem'
if (proxy == 'd18O' | proxy ==  'd13C'){
lipd[[ts]]$CategorySpecific <- paste(archive,' (',proxy,')',sep='')
} else{
lipd[[ts]]$CategorySpecific <- 'Speleothem (other)'
}
} else if (archive == 'LakeDeposits'){
lipd[[ts]]$Category           <- 'Lake Deposits'
lipd[[ts]]$CategorySpecific   <- 'Lake Deposits'
} else if (archive == 'GlacierIce'){
lipd[[ts]]$Category           <- 'Glacier Ice'
lipd[[ts]]$CategorySpecific   <- 'Glacier Ice'
} else if (archive == 'LakeSediment' & proxy == 'd18O'){
lipd[[ts]]$Category           <- 'Lake Sediment d18O'
lipd[[ts]]$CategorySpecific   <- 'Lake Sediment (d18O)'
} else if (proxy == 'dDwax'){
lipd[[ts]]$Category           <- 'Leaf Wax dD'
lipd[[ts]]$CategorySpecific   <- 'Leaf Wax (dD)'
} else if (proxy == 'pollen'){
lipd[[ts]]$Category           <- 'Pollen'
if (is.null(unit)){
lipd[[ts]]$CategorySpecific <- 'Pollen (not calibrated)'
} else if (unit == 'mm' | unit == 'mm/a'){
lipd[[ts]]$CategorySpecific <- 'Pollen (calibrated)'
} else {
lipd[[ts]]$CategorySpecific <- 'Pollen (not calibrated)'
}
} else {
lipd[[ts]]$Category           <- 'Other'
if (is.null(unit)){
lipd[[ts]]$CategorySpecific <- 'Other (not calibrated)'
} else if (unit == 'mm' | unit == 'mm/a'){
lipd[[ts]]$CategorySpecific <- 'Other (calibrated)'
} else {
lipd[[ts]]$CategorySpecific <- 'Other (not calibrated)'
}
}
} else{lipd[[ts]]$Category <- lipd[[ts]]$paleoData_proxyGeneral}
#
if (climVar == 'HC'){
if (is.null(lipd[[ts]]$createdBy)){lipd[[ts]]$createdBy <- ''}
if (is.null(lipd[[ts]]$originalDataUrl)){lipd[[ts]]$originalDataUrl <- ''}
if (is.null(lipd[[ts]]$paleoData_calibration_method)){lipd[[ts]]$paleoData_calibration_method <- ''}
if (is.null(lipd[[ts]]$pub1_doi)){lipd[[ts]]$pub1_doi <- ''}
if (is.null(lipd[[ts]]$pub2_doi)){lipd[[ts]]$pub2_doi <- ''}
if (lipd[[ts]]$createdBy == 'http://github.com/nickmckay/oxfordLakeStatus2Lipd'){
lipd[[ts]]$Source = 'Oxford Lake Levels Database'
}
#  dataSource.append('Oxford Lake Status')
else if (lipd[[ts]]$createdBy =='sisal2lipd'){
lipd[[ts]]$Source = 'SISAL'
}
# dataSource.append('SISAL (Comas-Bru et al., 2020)')
else if (lipd[[ts]]$originalDataUrl == 'wNAm'){
lipd[[ts]]$Source = 'wNA'
}
# dataSource.append('wNA')
else if (lipd[[ts]]$originalDataUrl == 'geochange.er.usgs.gov/midden/'){
lipd[[ts]]$Source = 'wNA'
}
# dataSource.append('wNA')
else if (lipd[[ts]]$paleoData_calibration_method == 'JM18_MAT'){
lipd[[ts]]$Source = 'Marsicek et al. (2018)'
}
# dataSource.append('Marsicek')
else if (grepl('gov/paleo/study/15444',lipd[[ts]]$originalDataUrl) | '10.5194/cp-10-1605-2014' == lipd[[ts]]$pub2_doi){
lipd[[ts]]$Source = 'Arctic Holocene'
}
#dataSource.append('Arctic Holocene')
else if (substr('lipd[[ts]]$dataSetName',1,2) == 'LS'){
lipd[[ts]]$Source = 'iso2k'
}
# dataSource.append('iso2k')
else if (lipd[[ts]]$originalDataUrl == 'https://essd.copernicus.org/articles/12/2261/2020/'){
lipd[[ts]]$Source = 'iso2k'
}
# dataSource.append('iso2k')
else if (grepl('10.25921/4RY2-G808',lipd[[ts]]$originalDataUrl) | grepl('/paleo/study/27330',lipd[[ts]]$originalDataUrl)){
lipd[[ts]]$Source = 'Temp12k'
}
#dataSource.append('Temp12k')
else{
lipd[[ts]]$Source = 'Miscellanious'
}# dataSource.append('Miscellanious')
} else{lipd[[ts]]$Source <- 'Temp12k'}
#
}
#require >0 change points for lakedeposits
lipd                <- lipd[which(!is.na(pullTsVariable(lipd,"ageResPlus")))]
lipdData[[climVar]] <- lipd[which(pullTsVariable(lipd,"climateInterpretation1_seasonalityGeneral") %in% c('summer+','winter+') == FALSE)]
}
print(paste("Temp:",length(lipdData$Temp)))
print(paste("HC:",length(lipdData$HC)))
###Save
saveRDS(lipdData, file.path(githubDir,'Data','LiPD','lipdData.rds'))
lipdData <- readRDS(file=file.path(githubDir,'Data','LiPD','lipdData.rds'))
PROJ       <- "+proj=robin +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
PROJorig   <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
refregions <- readShapePoly(file.path(githubDir,'Data','IPCC_refRegions','IPCC-WGI-reference-regions-v4.shp'),
proj4string=CRS(PROJorig))
refregions <-  spTransform(refregions, CRSobj = PROJ)
countries  <- getMap("less islands")
countries  <- spTransform(countries,  CRSobj = PROJ)
climVar    <- 'HC'
lipdTSO    <- lipdData[[climVar]]
climVarSettings    <- vector(mode='list')
climVarSettings$T  <- vector(mode='list')
climVarSettings$HC <- vector(mode='list')
climVarSettings$T$Pal  <- 'RdBu'
climVarSettings$T$Dir  <- 01
climVarSettings$T$Col  <- c("#FFEBEE","#FFCDD2","#EF9A9A") #reds
climVarSettings$T$Lab  <- "Cool <- (Standardized Anomoly) -> Warm"
climVarSettings$HC$Pal <- 'BrBG'
climVarSettings$HC$Dir <- 01
climVarSettings$HC$Col <- c("#E8EAF6","#303F9F","#1A237E") #indigo
climVarSettings$HC$Lab <- "Dry <- (Standardized Anomoly) -> Wet"
climVarSettings$HC$Lim <-  c(-2.5,2.5)
climVarSettings$HC$NAv <- 'light grey'
climVarSettings$HC$Seq <- seq(-2.2,2.2,0.4)
##############################
regionComposite <- vector(mode='list')
regionComposite$proxy <- read.csv(file.path(githubDir,'Data','RegionComposites/',climVar,'MedianTSbyRegion.csv'))
regionComposite$trace <- readRDS(file.path(githubDir,'Data','Model','trace.rds'))
regionComposite$hadcm <- readRDS(file.path(githubDir,'Data','Model','hadcm.rds'))
regNames <- names(regionComposite$proxy)[-1]
binvec <- regionComposite$proxy$time
ageMin <- min(binvec)
ageMax <- max(binvec)
refrenceSubset <- subset(refregions, Acronym %in% regNames)
basemap <- ggplot() +
#Set Border around plot - probably not the best way to do this
borders(aggregate(refregions, FUN=length), fill=NA, colour='black', size=2) +
geom_map(data=refregions, map=fortify(refregions),
aes(x=long, y=lat, group=group, map_id=id), fill="white", colour="white", size=1)+
#Add Country data (basemap)
geom_map(data=countries, map=fortify(countries),
aes(x=long, y=lat, group=group, map_id=id), fill = "grey80",color="grey90",size=0.2) +
borders(database = refrenceSubset, fill=NA, colour='grey20') +
coord_fixed(1) +
theme_void()
#basemap
climVar <- 'HC'
lipdTSO <- lipdData[[climVar]]
lipdTSO[[which(pullTsVariable(lipdTSO,'geo_ipccRegion')=='SOO')]]$geo_latitude <- -18.0918
lipdTSO[[which(pullTsVariable(lipdTSO,'geo_ipccRegion')=='SOO')]]$geo_longitude <- -57.5627
proxyMetaData <- tibble(dataset        = pullTsVariable(lipdTSO,'dataSetName'),
tsid           = pullTsVariable(lipdTSO,'paleoData_TSid'),
longitude      = pullTsVariable(lipdTSO,'geo_longitude'),
latitude       = pullTsVariable(lipdTSO,'geo_latitude'),
ipccReg        = pullTsVariable(lipdTSO,'geo_ipccRegion'),
Category       = pullTsVariable(lipdTSO,'Category'),
CategorySpec   = pullTsVariable(lipdTSO,'CategorySpecific'),
recordRange    = pullTsVariable(lipdTSO,'ageRange'),
recordRes      = pullTsVariable(lipdTSO,'ageRes'),
recordResPlus  = pullTsVariable(lipdTSO,'ageResPlus'))
proxyMetaData[which(proxyMetaData[,'ipccReg']=='SOO'),'ipccReg'] <- 'SES'
##############################
###Create list of color information
plotVals <- vector(mode='list')
plotVals$general  <- vector(mode='list')
plotVals$specific <- vector(mode='list')
plotVals$general$names  <- sort(unique(proxyMetaData$Category))
plotVals$general$colors <- c("powder blue","corn flower blue",
"dark blue","dark orchid","grey",
"forest green","firebrick")
plotVals$general$shapes <- c(12,21,15,5,13,14,11)
plotVals$specific$names <- sort(unique(proxyMetaData$CategorySpec))
plotVals$specific$colors<- c("powder blue","corn flower blue",
"dark blue","dark orchid","grey40","grey",
"forest green","yellowgreen","lightcoral","firebrick","darkorange")
plotVals$specific$shapes<- c(12,21,15,5,6,13,14,1,23,11,17)
plotSettings <- plotVals$specific
lipdData <- readRDS(file=file.path(githubDir,'Data','LiPD','lipdData.rds'))
PROJ       <- "+proj=robin +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
PROJorig   <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
refregions <- readShapePoly(file.path(githubDir,'Data','IPCC_refRegions','IPCC-WGI-reference-regions-v4.shp'),
proj4string=CRS(PROJorig))
refregions <-  spTransform(refregions, CRSobj = PROJ)
countries  <- getMap("less islands")
countries  <- spTransform(countries,  CRSobj = PROJ)
climVar    <- 'HC'
lipdTSO    <- lipdData[[climVar]]
climVar <- 'HC'
lipdTSO <- lipdData[[climVar]]
lipdTSO[[which(pullTsVariable(lipdTSO,'geo_ipccRegion')=='SOO')]]$geo_latitude <- -18.0918
lipdTSO[[which(pullTsVariable(lipdTSO,'geo_ipccRegion')=='SOO')]]$geo_longitude <- -57.5627
proxyMetaData <- tibble(dataset        = pullTsVariable(lipdTSO,'dataSetName'),
tsid           = pullTsVariable(lipdTSO,'paleoData_TSid'),
longitude      = pullTsVariable(lipdTSO,'geo_longitude'),
latitude       = pullTsVariable(lipdTSO,'geo_latitude'),
ipccReg        = pullTsVariable(lipdTSO,'geo_ipccRegion'),
Category       = pullTsVariable(lipdTSO,'Category'),
CategorySpec   = pullTsVariable(lipdTSO,'CategorySpecific'),
recordRange    = pullTsVariable(lipdTSO,'ageRange'),
recordRes      = pullTsVariable(lipdTSO,'ageRes'),
recordResPlus  = pullTsVariable(lipdTSO,'ageResPlus'))
proxyMetaData[which(proxyMetaData[,'ipccReg']=='SOO'),'ipccReg'] <- 'SES'
##############################
###Create list of color information
plotVals <- vector(mode='list')
plotVals$general  <- vector(mode='list')
plotVals$specific <- vector(mode='list')
plotVals$general$names  <- sort(unique(proxyMetaData$Category))
plotVals$general$colors <- c("powder blue","corn flower blue",
"dark blue","dark orchid","grey",
"forest green","firebrick")
plotVals$general$shapes <- c(12,21,15,5,13,14,11)
plotVals$specific$names <- sort(unique(proxyMetaData$CategorySpec))
plotVals$specific$colors<- c("powder blue","corn flower blue",
"dark blue","dark orchid","grey40","grey",
"forest green","yellowgreen","lightcoral","firebrick","darkorange")
plotVals$specific$shapes<- c(12,21,15,5,6,13,14,1,23,11,17)
plotSettings <- plotVals$specific
plotRes <- ggplot(proxyMetaData)+
geom_vline(xintercept=median(proxyMetaData$recordRes),size=1.1) +
geom_vline(xintercept=mean(proxyMetaData$recordRes),size=1.1,linetype=2) +
geom_histogram(aes(recordRes,fill=CategorySpec),color='Black',alpha=0.7,binwidth = 30) +
scale_fill_manual(values=plotSettings$colors) +
scale_x_continuous(name="Median Sample Resolution (binwidth = 30 years)" ,
limits=c(0,1250), expand=c(0,0), breaks=seq(0,1250,150)) +
scale_y_continuous(name="Count of Records", oob=scales::squish, limits=c(0,110), expand=c(0,0))+
theme_bw()+
theme(text = element_text(family='sans',size=20),
plot.background = element_rect(fill = 'white',color='Black'),
plot.margin = unit(c(0.25, 0.25, 0.2, 0.2), "in"),
legend.title = element_blank(),legend.position = 'none')# legend.position = c(0.5,0.7))
plotRes
##############################
plotResPlus <- ggplot(proxyMetaData)+
geom_vline(xintercept=median(proxyMetaData$recordResPlus),size=1.1) +
geom_vline(xintercept=mean(proxyMetaData$recordResPlus),size=1.1,linetype=2) +
geom_histogram(aes(recordResPlus,fill=CategorySpec),color='Black',alpha=0.7,binwidth = 30) +
scale_fill_manual(values=plotSettings$colors) +
scale_x_continuous(name = "Median Sample Resolution (binwidth = 30 years)" ,
limits=c(0,3000), expand=c(0,0), breaks=seq(0,1250,150)) +
scale_y_continuous(name="Count of Records", oob=scales::squish, limits=c(0,110), expand=c(0,0))+
theme_bw()+
theme(text = element_text(family='sans',size=20),
plot.background = element_rect(fill = 'white',color='Black'),
plot.margin = unit(c(0.25, 0.25, 0.2, 0.2), "in"),
legend.title = element_blank(),legend.position = 'none')# legend.position = c(0.5,0.7))
plotResPlus
ggsave(plot=plotRes, width = figS[1], height = figS[2], dpi = 600,
filename = file.path(githubDir,"Figures","PlotProxyAgeRes.png"))
ggsave(plot=plotResPlus, width = figS[1], height = figS[2], dpi = 600,
filename = file.path(githubDir,"Figures","PlotProxyAgeResPlus.png"))
proxyDataPrj   <- SpatialPointsDataFrame(proxyMetaData[,c("longitude", "latitude")], proxyMetaData, proj4string=CRS(PROJorig))
proxyDataPrj   <- spTransform(proxyDataPrj, CRSobj = PROJ)
refrenceSubset <- subset(refregions, Acronym %in% proxyMetaData$ipccReg)
dataTable <- fortify(refrenceSubset)
dataTable$Count     <- NA
dataTable$CountName <- NA
dataTable$Region    <- NA
#Set Breaks and color scheme with lowest group as grey
figBreaks <- c(5,10,20,30,40,60,80)
figlabels <- c(paste("<",figBreaks[1]+1),
paste(as.character(figBreaks[-length(figBreaks)]+1),"-",
as.character(figBreaks[-1])),
paste(">",figBreaks[length(figBreaks)]))
figPalette <- c("#CCCCCC",RColorBrewer::brewer.pal(n = 7, name = "YlOrBr"))
for (region in list(levels(refrenceSubset@data[["Acronym"]]))[[1]]){
i = which(refregions@data[["Acronym"]]==region)
count <- length(which(proxyMetaData$ipccReg==region))
if (count == 0){         countName <- NA
} else if (count <= figBreaks[1]){ countName <- 0
} else if (count <= figBreaks[2]){ countName <- 1
} else if (count <= figBreaks[3]){ countName <- 2
} else if (count <= figBreaks[4]){ countName <- 3
} else if (count <= figBreaks[5]){ countName <- 4
} else if (count <= figBreaks[6]){ countName <- 5
} else if (count <= figBreaks[7]){ countName <- 6
} else {countName <- 7}
dataTable$Count[which(dataTable$id==as.character(i-1))]     <- count
dataTable$CountName[which(dataTable$id==as.character(i-1))] <- countName
dataTable$Region[which(dataTable$id==as.character(i-1))]    <-region
}
basemap <- ggplot() +
#Set Border around plot - probably not the best way to do this
borders(aggregate(refregions, FUN=length), fill=NA, colour='black', size=3) +
geom_map(data=refregions, map=fortify(refregions),
aes(x=long, y=lat, group=group, map_id=id), fill="white", colour="white", size=1)+
#Add Country data (basemap)
geom_map(data=countries, map=fortify(countries),
aes(x=long, y=lat, group=group, map_id=id), fill = "grey80",color="grey90",size=0.2) +
coord_fixed(1) +
theme_void()
df <- as.data.frame(proxyDataPrj)
for (i in plotSettings$names){
df[which(df$CategorySpec==i),"CategorySpec"] <- paste(i,'   (n=',length(which(df$CategorySpec==i)),')',sep='')
}
##############################
#Plot Figure 1 proxy type for each site
proxyMapSites <- basemap +
geom_map(data=refrenceSubset, map=dataTable, alpha=0.75, size=0.5, color='black' ,
aes(x=long, y=lat, group=group, map_id=id),fill=NA) +
geom_star(data=df,aes(x=longitude.1 , y=latitude.1,starshape=CategorySpec, fill=CategorySpec),
size=4,color='Black',alpha=1,starstroke=0.5) +
scale_fill_manual(values=plotSettings$colors,name= 'Proxy Category') +
scale_starshape_manual(values=plotSettings$shapes,name= 'Proxy Category') +
theme(legend.position = 'none')
proxyMapSites
