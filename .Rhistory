legend.key.width  =(unit(40, 'points')), legend.key.height = (unit(10, 'points')),
legend.text =element_text(size=4,family="sans"), legend.spacing.y = unit(2, "points"),
legend.title=element_blank())
#
#
StripePlot <- StripePlot + draw_plot(legendPlt, x = 0.1, y = 0.1, width=0.8,height=0.12)
ggsave(plot=StripePlot, width = 6, height = 6*0.5072, dpi = 600,
filename = paste(file.path(githubDir,'Figures','global'),climVar,'_StripePlot.png',sep=''))
climVarSettings$T$Col  <- c("#FFEBEE","#FFCDD2","#EF9A9A") #reds
climVarSettings$T$Col  <- c("#B2DFDB","#00796B","#004D40") #reds
climVarSettings$T$Col  <- c("#FFEBEE","#FFCDD2","#EF9A9A") #reds
model_onoff <- TRUE
if (model_onoff){
modelTS <- vector(mode='list')
for (model in c('trace','hadcm')){
modelTS[[model]] <- read.csv(file.path(githubDir,'Data','Model','PseudoProxy_FullReg',
paste('T_annual_',model,'.csv',sep='')))
for (reg in regNames){
modelTS[[model]][,reg] <- (modelTS[[model]][,reg]-mean(modelTS[[model]][,reg]))/sd(modelTS[[model]][,reg])
}
}
}
for (reg in regNames){
timeAvail <- plotTimeAvailabilityTs(plotData[[reg]]$lipd,age.range=c(ageMin,ageMax),
group.var ='Category',step=100)$dat %>%
group_by(yvec) %>%
summarise(count=sum(value),countPct=sum(value)/length(plotData[[reg]]$lipd))
regionDataNA <- as.matrix(plotData[[reg]]$compMatix)
regionData <- regionDataNA
idx <- which(timeAvail$countPct<=0.5)
idx_MH <- which(timeAvail$yvec==6000)
if (length(idx > 0)){
idx <- c(max(which(timeAvail$countPct[1:idx_MH]<=0.5),
1),
min(which(timeAvail$countPct[idx_MH:length(timeAvail$countPct)]<=0.5)+idx_MH,
length(timeAvail$countPct)))
regionData[1:idx[1],] <- NA
regionData[idx[2]:length(timeAvail$countPct),] <- NA
}
plotlimit_set <- min(mean(c(max(abs(apply(regionData,1,median,na.rm=TRUE)),na.rm=TRUE),
max(abs(regionData),na.rm=TRUE))),8)
plotlimit_set <- 4.5
compBands <- vector(mode='list')
compBands$na <- plotTimeseriesEnsRibbons(X=binvec, Y=regionDataNA, alp=0.9,line.width=0.2,
color.low='grey90',
color.high='grey50',
color.line='grey20')
compBands$vals <- plotTimeseriesEnsRibbons(X=binvec, Y=regionData, alp=0.9,line.width=0.2,
color.low=climVarSettings[[climVar]]$Col[1],
color.high=climVarSettings[[climVar]]$Col[2],
color.line=climVarSettings[[climVar]]$Col[3])
if (model_onoff){
compBands$vals <- compBands$vals +
geom_line(aes(x=seq(0,12000,200),
y=modelTS[['trace']][,reg]),color = 'fire brick',
size=0.4,alpha=0.5) +
geom_line(aes(x=seq(0,12000,200),
y=modelTS[['hadcm']][,reg]),color = 'goldenrod',
size=0.4,alpha=0.5)
}
compBandPlt <- ggdraw()
for (plt in names(compBands)){
compBands[[plt]] <- compBands[[plt]] +
scale_x_reverse(name = "Age (yr BP)",
limits=c(12000,0), expand=c(0,0), n.breaks=7,sec.axis = dup_axis())+
scale_y_continuous(name=paste('Standardized',climVar),
limits=c(plotlimit_set*-1000,plotlimit_set*1000),sec.axis = dup_axis(),
breaks = seq(-4,4,2))+
coord_cartesian(xlim=c(12000,0),
ylim=c(plotlimit_set*-1,plotlimit_set)) +
theme_void() +
theme(panel.border=element_rect(colour='Black',fill=NA,size=0.8),
legend.position='none')
if (plt == names(compBands)[1]){
compBands[[plt]] <- compBands[[plt]] +
geom_hline(yintercept=0,size=0.15) +
theme(panel.background=element_rect(colour='Black',fill='White',size=0.8),
axis.ticks=element_line(color = 'black',size=0.2),
axis.ticks.length=unit(-4,"pt"))
}
compBandPlt <- compBandPlt + draw_plot(compBands[[plt]], x = 0, y = 0, width = 1, height = 1)
}
plotData[[reg]]$compBandPlt <- compBandPlt
#
}
#plotData[['EAS']]$compBandPlt
compBandPlt <- globalPlotOfRegions('compBandPlt',save=FALSE)
compBandPlt
ggsave(plot=compBandPlt, width = 19, height = 9, dpi = 600,
filename = paste(file.path(githubDir,'Figures','global'),climVar,'_compBandPlt.png',sep=''))
paste(file.path(githubDir,'Figures','global'),climVar,'_compBandPlt.png',sep='')
climVarSettings$T$Col  <- c("#B2DFDB","#00796B","#004D40") #reds
climVarSettings$T$Col  <- c("#FFEBEE","#FFCDD2","#EF9A9A") #reds
model_onoff <- TRUE
if (model_onoff){
modelTS <- vector(mode='list')
for (model in c('trace','hadcm')){
modelTS[[model]] <- read.csv(file.path(githubDir,'Data','Model','PseudoProxy_FullReg',
paste('P_annual_',model,'.csv',sep='')))
for (reg in regNames){
modelTS[[model]][,reg] <- (modelTS[[model]][,reg]-mean(modelTS[[model]][,reg]))/sd(modelTS[[model]][,reg])
}
}
}
for (reg in regNames){
timeAvail <- plotTimeAvailabilityTs(plotData[[reg]]$lipd,age.range=c(ageMin,ageMax),
group.var ='Category',step=100)$dat %>%
group_by(yvec) %>%
summarise(count=sum(value),countPct=sum(value)/length(plotData[[reg]]$lipd))
regionDataNA <- as.matrix(plotData[[reg]]$compMatix)
regionData <- regionDataNA
idx <- which(timeAvail$countPct<=0.5)
idx_MH <- which(timeAvail$yvec==6000)
if (length(idx > 0)){
idx <- c(max(which(timeAvail$countPct[1:idx_MH]<=0.5),
1),
min(which(timeAvail$countPct[idx_MH:length(timeAvail$countPct)]<=0.5)+idx_MH,
length(timeAvail$countPct)))
regionData[1:idx[1],] <- NA
regionData[idx[2]:length(timeAvail$countPct),] <- NA
}
plotlimit_set <- min(mean(c(max(abs(apply(regionData,1,median,na.rm=TRUE)),na.rm=TRUE),
max(abs(regionData),na.rm=TRUE))),8)
plotlimit_set <- 4.5
compBands <- vector(mode='list')
compBands$na <- plotTimeseriesEnsRibbons(X=binvec, Y=regionDataNA, alp=0.9,line.width=0.2,
color.low='grey90',
color.high='grey50',
color.line='grey20')
compBands$vals <- plotTimeseriesEnsRibbons(X=binvec, Y=regionData, alp=0.9,line.width=0.2,
color.low=climVarSettings[[climVar]]$Col[1],
color.high=climVarSettings[[climVar]]$Col[2],
color.line=climVarSettings[[climVar]]$Col[3])
if (model_onoff){
compBands$vals <- compBands$vals +
geom_line(aes(x=seq(0,12000,200),
y=modelTS[['trace']][,reg]),color = 'fire brick',
size=0.4,alpha=0.5) +
geom_line(aes(x=seq(0,12000,200),
y=modelTS[['hadcm']][,reg]),color = 'goldenrod',
size=0.4,alpha=0.5)
}
compBandPlt <- ggdraw()
for (plt in names(compBands)){
compBands[[plt]] <- compBands[[plt]] +
scale_x_reverse(name = "Age (yr BP)",
limits=c(12000,0), expand=c(0,0), n.breaks=7,sec.axis = dup_axis())+
scale_y_continuous(name=paste('Standardized',climVar),
limits=c(plotlimit_set*-1000,plotlimit_set*1000),sec.axis = dup_axis(),
breaks = seq(-4,4,2))+
coord_cartesian(xlim=c(12000,0),
ylim=c(plotlimit_set*-1,plotlimit_set)) +
theme_void() +
theme(panel.border=element_rect(colour='Black',fill=NA,size=0.8),
legend.position='none')
if (plt == names(compBands)[1]){
compBands[[plt]] <- compBands[[plt]] +
geom_hline(yintercept=0,size=0.15) +
theme(panel.background=element_rect(colour='Black',fill='White',size=0.8),
axis.ticks=element_line(color = 'black',size=0.2),
axis.ticks.length=unit(-4,"pt"))
}
compBandPlt <- compBandPlt + draw_plot(compBands[[plt]], x = 0, y = 0, width = 1, height = 1)
}
plotData[[reg]]$compBandPlt <- compBandPlt
#
}
#plotData[['EAS']]$compBandPlt
compBandPlt <- globalPlotOfRegions('compBandPlt',save=FALSE)
compBandPlt
ggsave(plot=compBandPlt, width = 19, height = 9, dpi = 600,
filename = paste(file.path(githubDir,'Figures','global'),climVar,'_compBandPlt.png',sep=''))
#githubDir <- getwd()
climVar <- 'HC'
compositeData <- read.csv(file.path(githubDir,'Data','RegionComposites',climVar,'MedianTSbyRegion.csv'))
#Calculate data to plot and connect it to region data.
#More complicated than needed because part of larger code to make series of figures for each region
pcaData <-vector(mode='list')
for (region in names(compositeData)[-1]){ #First column is the time variable
pcaData[[region]]           <- vector(mode="list")
pcaData[[region]][['Name']] <- region
#Load region composite matrix csv
pcaData[[region]]$compMatix <- read.csv(file.path(githubDir,'Data','RegionComposites',climVar,
paste(region,'csv',sep='.')))
}
pcaData[[region]]$compMatix
View(pcaData[[region]]$compMatix)
#githubDir <- getwd()
climVar <- 'HC'
compositeData <- read.csv(file.path(githubDir,'Data','RegionComposites',climVar,'MedianTSbyRegion.csv'))
lipdTSO       <- readRDS(file=file.path(githubDir,'Data','LiPD','lipdData.rds'))[[climVar]]
#Set up PCA input
pcaInList <- vector(mode = "list")
for (region in names(compositeData)[-1]){
lipdReg    <- filterTs(lipdTSO,paste('geo_ipccRegion ==',reg))
regCount   <- length(lipdReg)
#Skip if number of records is too few
#
#Calculate data density throughout the Holocene
timeN <- plotTimeAvailabilityTs(lipdReg,
age.range=c(0,12000),
group.var ='Category',
step=binsize)$dat %>%
group_by(yvec) %>%
summarise(count=sum(value),countPct=sum(value)/regCount)
#Determine search range based on 0-10ka with >50% proxy coverage
MH <- which(timeN$yvec==6000)
if (length(which(timeN$countPct<=0.5) > 0)){
idx <- c(max(which(timeN$countPct[1:MH]<=0.5),
which(timeN$yvec==0)),
min(which(timeN$countPct[MH:length(timeN$countPct)]<=0.5)+MH,
which(timeN$yvec==12000)))
} else{
idx <- c(which(timeN$yvec==0),which(timeN$yvec==12000))
}
searchMin  <- timeN$yvec[idx[1]] #age BP
searchMax  <- timeN$yvec[idx[2]] #age BP
#
pcaInList[[region]]   <- binEns(compositeData[,1], #Time sequence of data
as.matrix(pcaData[[region]]$compMatix), #Output of composite code
seq(searchMin,searchMax,100), #bin only over this range change to 8000 to make work
bin.fun = mean,
max.ens = NA)
}
#Set up PCA input
pcaInList <- vector(mode = "list")
for (reg in names(compositeData)[-1]){
lipdReg    <- filterTs(lipdTSO,paste('geo_ipccRegion ==',reg))
regCount   <- length(lipdReg)
#Skip if number of records is too few
#
#Calculate data density throughout the Holocene
timeN <- plotTimeAvailabilityTs(lipdReg,
age.range=c(0,12000),
group.var ='Category',
step=binsize)$dat %>%
group_by(yvec) %>%
summarise(count=sum(value),countPct=sum(value)/regCount)
#Determine search range based on 0-10ka with >50% proxy coverage
MH <- which(timeN$yvec==6000)
if (length(which(timeN$countPct<=0.5) > 0)){
idx <- c(max(which(timeN$countPct[1:MH]<=0.5),
which(timeN$yvec==0)),
min(which(timeN$countPct[MH:length(timeN$countPct)]<=0.5)+MH,
which(timeN$yvec==12000)))
} else{
idx <- c(which(timeN$yvec==0),which(timeN$yvec==12000))
}
searchMin  <- timeN$yvec[idx[1]] #age BP
searchMax  <- timeN$yvec[idx[2]] #age BP
#
pcaInList[[reg]]   <- binEns(compositeData[,1], #Time sequence of data
as.matrix(pcaData[[reg]]$compMatix), #Output of composite code
seq(searchMin,searchMax,100), #bin only over this range change to 8000 to make work
bin.fun = mean,
max.ens = NA)
}
#Set up PCA input
pcaInList <- vector(mode = "list")
for (reg in names(compositeData)[-1]){
lipdReg    <- filterTs(lipdTSO,paste('geo_ipccRegion ==',reg))
regCount   <- length(lipdReg)
#Skip if number of records is too few
#
#Calculate data density throughout the Holocene
timeN <- plotTimeAvailabilityTs(lipdReg,
age.range=c(0,12000),
group.var ='Category',
step=100)$dat %>%
group_by(yvec) %>%
summarise(count=sum(value),countPct=sum(value)/regCount)
#Determine search range based on 0-10ka with >50% proxy coverage
MH <- which(timeN$yvec==6000)
if (length(which(timeN$countPct<=0.5) > 0)){
idx <- c(max(which(timeN$countPct[1:MH]<=0.5),
which(timeN$yvec==0)),
min(which(timeN$countPct[MH:length(timeN$countPct)]<=0.5)+MH,
which(timeN$yvec==12000)))
} else{
idx <- c(which(timeN$yvec==0),which(timeN$yvec==12000))
}
searchMin  <- timeN$yvec[idx[1]] #age BP
searchMax  <- timeN$yvec[idx[2]] #age BP
#
pcaInList[[reg]]   <- binEns(compositeData[,1], #Time sequence of data
as.matrix(pcaData[[reg]]$compMatix), #Output of composite code
seq(searchMin,searchMax,100), #bin only over this range change to 8000 to make work
bin.fun = mean,
max.ens = NA)
}
print(length(pcaInList))
pcaOut <- geoChronR::pcaEns(pcaInList)
pcaLoadingsMean <- apply(pcaOut$loadings,c(1,2),mean)
pcaOut <- geoChronR::pcaEns(pcaInList)
?pcaEns
compositeData[,1]
pcaData[[reg]]           <- vector(mode="list")
pcaData[[reg]][['Name']] <- reg
#Load region composite matrix csv
pcaData[[reg]]$compMatix <- read.csv(file.path(githubDir,'Data',
'RegionComposites',climVar,
paste(reg,'csv',sep='.')))
#
#
lipdReg    <- filterTs(lipdTSO,paste('geo_ipccRegion ==',reg))
regCount   <- length(lipdReg)
#Skip if number of records is too few
#
#Calculate data density throughout the Holocene
timeN <- plotTimeAvailabilityTs(lipdReg,
age.range=c(0,12000),
group.var ='Category',
step=100)$dat %>%
group_by(yvec) %>%
summarise(count=sum(value),countPct=sum(value)/regCount)
timeN
compositeData[,1]
#Determine search range based on 0-10ka with >50% proxy coverage
MH <- which(timeN$yvec==6000)
if (length(which(timeN$countPct<=0.5) > 0)){
idx <- c(max(which(timeN$countPct[1:MH]<=0.5),
which(timeN$yvec==0)),
min(which(timeN$countPct[MH:length(timeN$countPct)]<=0.5)+MH,
which(timeN$yvec==12000)))
} else{
idx <- c(which(timeN$yvec==0),which(timeN$yvec==12000))
}
searchMin  <- which(compositeData[,1]==timeN$yvec[idx[1]]) #age BP
searchMax  <- which(compositeData[,1]==timeN$yvec[idx[2]]) #age BP
print(c(searchMin,searchMax))
pcaData[[reg]]$compMatix
dim(pcaData[[reg]]$compMatix)
pcaData[[reg]]$compMatix[1:searchMin,]
dim(pcaData[[reg]]$compMatix[1:searchMin,])
pcaData[[reg]]$compMatix <- pcaData[[reg]]$compMatix[1:searchMin,] <- NA
pcaData[[reg]]$compMatix <- pcaData[[reg]]$compMatix[searchMax,length(compositeData[,1])] <- NA
pcaData[[reg]]$compMatix <- pcaData[[reg]]$compMatix[searchMax:length(compositeData[,1]),] <- NA
length(compositeData[,1])
pcaData[[reg]]$compMatix <- pcaData[[reg]]$compMatix[searchMax:126,] <- NA
print(c(searchMin,searchMax))
pcaData[[reg]]$compMatix[1:searchMin,] <- NA
pcaData[[reg]]$compMatix[searchMax:length(compositeData[,1]),] <- NA
pcaData[[reg]]           <- vector(mode="list")
pcaData[[reg]][['Name']] <- reg
#Load region composite matrix csv
pcaData[[reg]]$compMatix <- read.csv(file.path(githubDir,'Data',
'RegionComposites',climVar,
paste(reg,'csv',sep='.')))
#
#
lipdReg    <- filterTs(lipdTSO,paste('geo_ipccRegion ==',reg))
regCount   <- length(lipdReg)
#Skip if number of records is too few
#
#Calculate data density throughout the Holocene
timeN <- plotTimeAvailabilityTs(lipdReg,
age.range=c(0,12000),
group.var ='Category',
step=100)$dat %>%
group_by(yvec) %>%
summarise(count=sum(value),countPct=sum(value)/regCount)
#Determine search range based on 0-10ka with >50% proxy coverage
MH <- which(timeN$yvec==6000)
if (length(which(timeN$countPct<=0.5) > 0)){
idx <- c(max(which(timeN$countPct[1:MH]<=0.5),
which(timeN$yvec==0)),
min(which(timeN$countPct[MH:length(timeN$countPct)]<=0.5)+MH,
which(timeN$yvec==12000)))
} else{
idx <- c(which(timeN$yvec==0),which(timeN$yvec==12000))
}
searchMin  <- which(compositeData[,1]==timeN$yvec[idx[1]]) #age BP
searchMax  <- which(compositeData[,1]==timeN$yvec[idx[2]]) #age BP
print(c(searchMin,searchMax))
pcaData[[reg]]$compMatix[1:searchMin,]
dim(pcaData[[reg]]$compMatix[1:searchMin,])
dim(pcaData[[reg]]$compMatix[searchMax:length(compositeData[,1]),])
print(c(searchMin,searchMax))
pcaData[[reg]]$compMatix[1:searchMin,] <- NA
pcaData[[reg]]$compMatix[searchMax:length(compositeData[,1]),] <- NA
#Calculate data to plot and connect it to region data.
#More complicated than needed because part of larger code to make series of figures for each region
pcaData <-vector(mode='list')
for (reg in names(compositeData)[-1]){ #First column is the time variable
pcaData[[reg]]           <- vector(mode="list")
pcaData[[reg]][['Name']] <- reg
#Load region composite matrix csv
pcaData[[reg]]$compMatix <- read.csv(file.path(githubDir,'Data',
'RegionComposites',climVar,
paste(reg,'csv',sep='.')))
#
#
lipdReg    <- filterTs(lipdTSO,paste('geo_ipccRegion ==',reg))
regCount   <- length(lipdReg)
#Skip if number of records is too few
#
#Calculate data density throughout the Holocene
timeN <- plotTimeAvailabilityTs(lipdReg,
age.range=c(0,12000),
group.var ='Category',
step=100)$dat %>%
group_by(yvec) %>%
summarise(count=sum(value),countPct=sum(value)/regCount)
#Determine search range based on 0-10ka with >50% proxy coverage
MH <- which(timeN$yvec==6000)
if (length(which(timeN$countPct<=0.5) > 0)){
idx <- c(max(which(timeN$countPct[1:MH]<=0.5),
which(timeN$yvec==0)),
min(which(timeN$countPct[MH:length(timeN$countPct)]<=0.5)+MH,
which(timeN$yvec==12000)))
} else{
idx <- c(which(timeN$yvec==0),which(timeN$yvec==12000))
}
searchMin  <- which(compositeData[,1]==timeN$yvec[idx[1]]) #age BP
searchMax  <- which(compositeData[,1]==timeN$yvec[idx[2]]) #age BP
print(c(searchMin,searchMax))
pcaData[[reg]]$compMatix[1:searchMin,] <- NA
pcaData[[reg]]$compMatix[searchMax:length(compositeData[,1]),] <- NA
#
}
#Set up PCA input
pcaInList <- vector(mode = "list")
for (reg in names(compositeData)[-1]){
pcaInList[[reg]]   <- binEns(compositeData[,1], #Time sequence of data
as.matrix(pcaData[[reg]]$compMatix), #Output of composite code
seq(searchMin,searchMax,100), #bin only over this range change to 8000 to make work
bin.fun = mean,
max.ens = NA)
}
print(length(pcaInList))
pcaOut <- geoChronR::pcaEns(pcaInList)
pcaLoadingsMean <- apply(pcaOut$loadings,c(1,2),mean)
pcaOut <- geoChronR::pcaEns(pcaInList)
#Set up PCA input
pcaInList <- vector(mode = "list")
#Set up PCA input
pcaInList <- vector(mode = "list")
for (reg in names(compositeData)[-1]){
pcaInList[[reg]]   <- binEns(compositeData[,1], #Time sequence of data
as.matrix(pcaData[[reg]]$compMatix), #Output of composite code
seq(0,12000,100), #bin only over this range change to 8000 to make work
bin.fun = mean,
max.ens = NA)
}
#Set up PCA input
pcaInList <- vector(mode = "list")
for (reg in names(compositeData)[-1]){
pcaInList[[reg]]   <- binEns(compositeData[,1], #Time sequence of data
as.matrix(pcaData[[reg]]$compMatix), #Output of composite code
seq(0,12000,100), #bin only over this range change to 8000 to make work
bin.fun = mean,
max.ens = NA)
}
print(length(pcaInList))
pcaOut <- geoChronR::pcaEns(pcaInList)
pcaLoadingsMean <- apply(pcaOut$loadings,c(1,2),mean)
pcaLoadingsMean <- as.data.frame(pcaLoadingsMean,row.names = names(pcaInList))
colnames(pcaLoadingsMean) <- paste('PC',as.character(c(1:ncol(pcaLoadingsMean))),sep='')
#Save Output
saveRDS(pcaOut,file.path(githubDir,'Data','RegionComposites','PCA','pcaHC12k.rds'))
saveRDS(pcaLoadingsMean,file.path(githubDir,'Data','RegionComposites','PCA','pcaLoadingsMean.rds'))
pc <- 2
dataTable <- fortify(refrenceSubset)
dataTable$Count     <- NA
for (reg in list(levels(refrenceSubset@data[["Acronym"]]))[[1]]){
i = which(refregions@data[["Acronym"]]==reg)
loading <- apply(pca[["loadings"]][,pc,],1,median,na.rm=TRUE)[which(regNames==reg)]
dataTable$Count[which(dataTable$id==as.character(i-1))] <- loading
}
#Load PCA data
pca <- readRDS(file.path(githubDir,'Data','RegionComposites','PCA','pcaHC12k.rds'))
plotPcaEns(pca)
pc <- 2
dataTable <- fortify(refrenceSubset)
dataTable$Count     <- NA
for (reg in list(levels(refrenceSubset@data[["Acronym"]]))[[1]]){
i = which(refregions@data[["Acronym"]]==reg)
loading <- apply(pca[["loadings"]][,pc,],1,median,na.rm=TRUE)[which(regNames==reg)]
dataTable$Count[which(dataTable$id==as.character(i-1))] <- loading
}
pcMapplot <- basemap +
#Add refrence regions boundaries
geom_map(data=refrenceSubset, map=dataTable, alpha=0.75, size=0.5, color='black' ,
aes(x=long, y=lat, group=group, map_id=id,fill=dataTable$Count)) +
scale_fill_binned(type = "viridis",name =paste('Loading (PC',pc,')',sep='')) +
theme(text = element_text(family='sans',size=12),
plot.background = element_rect(fill = 'white',color='White'),
plot.margin = unit(c(0.25, 0.25, 0.2, 0.2), "in"),
legend.position = c(0.5,0.12),
legend.direction='horizontal',
legend.box.background=element_rect(fill = 'white',color='Black'),
legend.box.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"),
legend.key.width=unit(30, 'points'),
legend.key.height=unit(8, 'points'))
pcTSplot <- ggplot() +
geom_line(aes(x=pca[["age"]]/1000,y=apply(pca[["PCs"]][,pc,],1,median,na.rm=TRUE)),
color='Black',size=1)+
labs(x='Age (yr BP)',y='Wet <    > Dry',subtitle=paste('PC',pc,sep='')) +
theme_bw() +
scale_x_reverse(name = "Age (ka BP)",
limits=c(12,0), expand=c(0,0), n.breaks=7) +
theme(text = element_text(family='sans',size=18),
plot.background = element_rect(fill = 'white',color='White'),
plot.margin = unit(c(0.25, 0.25, 0.2, 0.2), "in"))
ggsave(plot=pcTSplot, width = 6, height = 3, dpi = 600,
filename = paste(file.path(githubDir,'Figures','global_PC'),pc,'_TS.png',sep=''))
ggsave(plot=pcMapplot, width = 6, height = 3.5, dpi = 600,
filename = paste(file.path(githubDir,'Figures','global_PC'),pc,'_Map.png',sep=''))
#which(regNames=reg)
#Load PCA data
pca <- readRDS(file.path(githubDir,'Data','RegionComposites','PCA','pcaHC12k.rds'))
#plotPcaEns(pca)
